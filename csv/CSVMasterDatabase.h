#pragma once
#ifdef NOT_USED___
#include <string>
#include <vector>
#include <cstdlib>
#include <memory>
#include "DBDefines.h"
#include "MetadataObject.h"

#include "ArchivePath.h"


#define MetadataTableName		"Metadata"
#define MetadataTableFilename	"Metadata.csv"

/**
* @brief This is the main interface into the CSV Database. This Database is used
* to create a Comma Separated Value based database.
* The created files in the database are stored in a directory tree. This directory tree
* is defined by a year folder, day folder hierarchy much like the main archive folder hierarchy
* The aim is to limit the resulting files to a manageable size.
* In addition so the metadata records are also a manageable length, the matedata is spit up
* into sections. each section it  associated by a unique sequence number. Which will become the primary
* key to each of these table files This sequence number is generated by other the SQL database or this
* database if the SQL one is not enabled.
*/

namespace simplearchive {

	class MirrorDB;
	//class CSVDatabase : MTDatabase {
	class CSVMasterDatabase {
		CSVMasterDatabase();
		static std::shared_ptr<CSVMasterDatabase> m_this;
		static std::string m_dbpath;
		//std::unique_ptr<MirrorDB> m_mirrorDB;

	public:
		/// Set the database path for the archive. This will normally under Master/.root
		static void setDBPath(const char *path);
		/// gets the database instance.
		static CSVMasterDatabase &get();
		/// destructor
		virtual ~CSVMasterDatabase();

		void add(MetadataObject &metadataObject, const char *relpath);
		void update(MetadataObject &metadataObject, unsigned int idx, const char *path);
		const MetadataObject *get(unsigned int idx, const char *path);
		std::shared_ptr<MetadataObject> get(const char *name, const char *path);
		bool put(const char *name, const char *path, MetadataObject &mo);

		bool copy(const char *path);
		bool validate(const char *path);

	};

} // namespace simplearchive {
#endif